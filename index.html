<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caffora: Hand Controlled Particles</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        /* Hide the raw video feed, we only want the particles */
        #input_video { display: none; }
        
        #ui-layer {
            position: absolute;
            top: 20px; left: 20px;
            color: white;
            z-index: 10;
            pointer-events: none;
        }
        .status {
            background: rgba(0,0,0,0.6);
            border-left: 3px solid cyan;
            padding: 15px;
            backdrop-filter: blur(4px);
        }
        .guide { margin-top: 10px; font-size: 0.9em; color: #ccc; }
        .loading { color: yellow; animation: flash 1s infinite; }
        @keyframes flash { 0% { opacity: 1; } 50% { opacity: 0.5; } }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="status">
            <h2>Caffora Vision</h2>
            <div id="status-text" class="loading">Waiting for Camera...</div>
            <div class="guide">
                üñê <strong>Open Palm:</strong> Move Particles<br>
                üëå <strong>Pinch (Index+Thumb):</strong> Gravity Well (Attract)<br>
                ‚úä <strong>Closed Fist:</strong> Shockwave (Repel)
            </div>
        </div>
    </div>

    <video id="input_video"></video>
    <div id="canvas-container"></div>

    <script>
        // --- 1. CONFIGURATION ---
        const CONFIG = {
            particleCount: 20000, 
            cameraZ: 400,
            interactionRadius: 180,
            viscosity: 0.95,
            restorationForce: 0.03
        };

        // --- 2. STATE MANAGEMENT ---
        let scene, camera, renderer, particles;
        let positions, velocities, originalPositions, colors;
        
        // Input State (Bridging MediaPipe -> Three.js)
        const input = {
            x: 9999, y: 9999, z: 0, // Start off-screen
            isPinching: false,
            isFist: false,
            isActive: false
        };

        // --- 3. THREE.JS SETUP ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.z = CONFIG.cameraZ;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            createParticles();
            animate();
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            positions = new Float32Array(CONFIG.particleCount * 3);
            originalPositions = new Float32Array(CONFIG.particleCount * 3);
            velocities = new Float32Array(CONFIG.particleCount * 3);
            colors = new Float32Array(CONFIG.particleCount * 3);

            const colorObj = new THREE.Color();

            for (let i = 0; i < CONFIG.particleCount; i++) {
                // Galaxy Spiral Distribution
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 300 + 50; 
                const spiralOffset = angle * 20;

                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius; // Flattened galaxy
                const z = (Math.random() - 0.5) * 200;

                positions[i*3] = x;
                positions[i*3+1] = y;
                positions[i*3+2] = z;
                
                originalPositions[i*3] = x;
                originalPositions[i*3+1] = y;
                originalPositions[i*3+2] = z;

                // Color Gradient (Cyan to Magenta)
                colorObj.setHSL(0.5 + Math.random()*0.4, 0.8, 0.6);
                colors[i*3] = colorObj.r;
                colors[i*3+1] = colorObj.g;
                colors[i*3+2] = colorObj.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Simple soft texture
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createRadialGradient(16,16,0,16,16,16);
            grd.addColorStop(0, 'rgba(255,255,255,1)');
            grd.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grd;
            ctx.fillRect(0,0,32,32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.PointsMaterial({
                size: 4,
                map: texture,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- 4. PHYSICS LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Access attributes
            const posAttr = particles.geometry.attributes.position;
            const colAttr = particles.geometry.attributes.color;

            // Slow idle rotation
            if (!input.isActive) {
                particles.rotation.z += 0.002;
            }

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                const px = positions[ix];
                const py = positions[iy];
                const pz = positions[iz];

                // --- INTERACTION PHYSICS ---
                if (input.isActive) {
                    const dx = input.x - px;
                    const dy = input.y - py;
                    const dz = input.z - pz; // Approximate depth
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

                    if (dist < CONFIG.interactionRadius) {
                        const force = (CONFIG.interactionRadius - dist) / CONFIG.interactionRadius;
                        
                        if (input.isPinching) {
                            // BLACK HOLE (Attract)
                            velocities[ix] += dx * force * 0.1;
                            velocities[iy] += dy * force * 0.1;
                            velocities[iz] += dz * force * 0.1;
                        } else if (input.isFist) {
                            // EXPLOSION (Repel)
                            velocities[ix] -= dx * force * 0.3;
                            velocities[iy] -= dy * force * 0.3;
                            velocities[iz] -= dz * force * 0.3;
                        } else {
                            // TURBULENCE (Move)
                            velocities[ix] -= dx * force * 0.02;
                            velocities[iy] -= dy * force * 0.02;
                            velocities[iz] -= dz * force * 0.02;
                        }
                    }
                }

                // --- RESTORATION (Return home) ---
                const ox = originalPositions[ix];
                const oy = originalPositions[iy];
                const oz = originalPositions[iz];
                
                velocities[ix] += (ox - px) * CONFIG.restorationForce;
                velocities[iy] += (oy - py) * CONFIG.restorationForce;
                velocities[iz] += (oz - pz) * CONFIG.restorationForce;

                // --- UPDATE ---
                velocities[ix] *= CONFIG.viscosity;
                velocities[iy] *= CONFIG.viscosity;
                velocities[iz] *= CONFIG.viscosity;

                positions[ix] += velocities[ix];
                positions[iy] += velocities[iy];
                positions[iz] += velocities[iz];

                // Color Reaction (Brighten on high velocity)
                const speed = Math.abs(velocities[ix]) + Math.abs(velocities[iy]);
                if (speed > 1.5) {
                    colAttr.array[ix] = 1; // R
                    colAttr.array[iy] = 1; // G
                    colAttr.array[iz] = 1; // B
                } else {
                    // Reset to original-ish color logic (simplified)
                    colAttr.array[ix] *= 0.98; // Fade back
                    // (Real implementation requires storing original colors to fade back accurately)
                }
            }
            
            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- 5. MEDIAPIPE HANDS SETUP ---
        const videoElement = document.getElementById('input_video');
        const statusText = document.getElementById('status-text');

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // MAP LANDMARKS TO ACTIONS
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                input.isActive = true;
                statusText.innerText = "System Active: Hand Tracking";
                statusText.style.color = "#0f0";
                statusText.classList.remove('loading');

                const landmarks = results.multiHandLandmarks[0];
                
                // 1. POSITION MAPPING
                // Normalize 0-1 to Three.js coordinates (-width/2 to width/2)
                // Note: landmarks.x is 0 on left, 1 on right. 
                // We flip X (1 - x) because webcam is mirrored.
                const x = (1 - landmarks[9].x) * window.innerWidth - window.innerWidth / 2;
                const y = (1 - landmarks[9].y) * window.innerHeight - window.innerHeight / 2;
                // Simple depth approximation using hand size (wrist to middle finger tip)
                // Closer hand = larger distance in frame = closer z
                const z = 0; 

                // Smoothing input
                input.x += (x - input.x) * 0.3;
                input.y += (y - input.y) * 0.3;
                input.z = z;

                // 2. GESTURE RECOGNITION

                // Check Pinch: Distance between Index Tip (8) and Thumb Tip (4)
                const pinchDist = distance(landmarks[8], landmarks[4]);
                input.isPinching = pinchDist < 0.05;

                // Check Fist: Tips of fingers close to wrist (0)
                // Tip IDs: 8, 12, 16, 20. Wrist: 0
                const ringTipDist = distance(landmarks[16], landmarks[0]);
                const pinkyTipDist = distance(landmarks[20], landmarks[0]);
                // If ring and pinky are curled in, we assume fist-like behavior for repulsion
                input.isFist = ringTipDist < 0.15 && pinkyTipDist < 0.15;

            } else {
                input.isActive = false;
                statusText.innerText = "Waiting for Hand...";
                statusText.style.color = "yellow";
            }
        }

        // Helper for Euclidean distance between two landmarks
        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) + Math.pow(p1.z - p2.z, 2));
        }

        // Initialize Camera
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        // Start Everything
        initThree();
        cameraUtils.start();

    </script>
</body>
</html>